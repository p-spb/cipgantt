<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CIP Gantt Timeline</title>

  <!-- vis-timeline (MIT) -->
  <link href="https://cdn.jsdelivr.net/npm/vis-timeline@7.7.3/styles/vis-timeline-graph2d.min.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/vis-data@7.1.9/peer/umd/vis-data.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vis-timeline@7.7.3/standalone/umd/vis-timeline-graph2d.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx-js-style@1.2.0/dist/xlsx.bundle.js"></script>


  <style>
    html, body { height: 100%; margin: 0; }
    #wrap { height: 100%; display: flex; flex-direction: column; }
    #header {
      padding: 10px 12px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
    }
    #status { opacity: .75; }
    #timeline { flex: 1; }

    /* Controls */
    #controls { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .ctl {
      padding: 6px 10px;
      border: 1px solid rgba(0,0,0,.2);
      border-radius: 8px;
      font-size: 14px;
      background: #fff;
    }
    #contactSelect { min-width: 280px; }
    .btn {
      padding: 6px 10px;
      border: 1px solid rgba(0,0,0,.2);
      border-radius: 8px;
      background: #fff;
      cursor: pointer;
      font-size: 14px;
    }
    .btn:hover { background: rgba(0,0,0,.04); }

    /* Non-interactive timeline only */
    .timelineNonInteractive #timeline { pointer-events: none; }
    .timelineNonInteractive .vis-item { pointer-events: none; }
    .timelineNonInteractive .vis-custom-time { pointer-events: none; }

    /* Segment colors by status */
    .seg-closed { background: #2e7d32; border-color: #2e7d32; color: #fff; }         /* green */
    .seg-design { background: #1565c0; border-color: #1565c0; color: #fff; }         /* blue */
    .seg-hold { background: #7b1fa2; border-color: #7b1fa2; color: #fff; }           /* purple */
    .seg-risk { background: #c62828; border-color: #c62828; color: #fff; }           /* red */
    .seg-substantial { background: #f2c6a0; border-color: #f2c6a0; color: #333; }    /* light peach */
    .seg-active { background: #7ec8ff; border-color: #7ec8ff; color: #0b2a3a; }     /* light blue */

    /* “Gantt bar” look */
    .vis-item.vis-range { border-radius: 6px; }
    .vis-item .vis-item-content { font-size: 12px; padding: 2px 6px; }

    /* Today line styling */
    .vis-custom-time.today-line {
      background-color: rgba(0,0,0,0.35);
      width: 2px;
    }

    /* Left label as "ID  Name" */
    .vis-group-content { white-space: nowrap; }
    .vis-group-content strong {
      display: inline-block;
      min-width: 70px;
      text-align: right;
    }
  </style>
</head>

<body class="timelineNonInteractive">
  <div id="wrap">
    <div id="header">
      <strong>CIP Timeline</strong>

      <div id="controls">
        <label style="opacity:.8;">Contact:</label>
        <select id="contactSelect" class="ctl" title="Filter by Contact_Name"></select>

        <button id="clearBtn" class="btn" type="button">Clear</button>
        <button id="exportCalendarXlsxBtn" class="btn" type="button">Export Calendar XLSX</button>



      </div>

      <span id="status"></span>
    </div>

    <div id="timeline"></div>
  </div>

  <script>
    // -----------------------------
    // CONFIG
    // -----------------------------
    const FEATURESERVER_URL =
      "https://services8.arcgis.com/F3eqpl8ixwADS2P2/arcgis/rest/services/CIP_Gantt_Chart_View/FeatureServer";
    const LAYER_INDEX = 5;

    const PROJECT_ID_FIELD = "ProjectID";
    const PROJECT_NAME_FIELD = "Public_Project_Name";
    const CONTACT_FIELD = "Contact_Name";

    // Start + End fields per phase (explicit)
    const PHASES = [
      {
        startKey: "InDesignorProcurementDate",
        endKey:   "InDesignorProcurementEnd",
        label: "In Design / Procurement",
        className: "seg-design"
      },
      {
        startKey: "ActiveImplementationConstructionDate",
        endKey:   "ActiveImplementationConstructionEnd",
        label: "Active Implementation / Construction",
        className: "seg-active"
      },
      {
        startKey: "SubstantialCompletionorTestingDate",
        endKey:   "SubstantialCompletionorTestingEnd",
        label: "Substantial Completion / Testing",
        className: "seg-substantial"
      },
      {
        startKey: "ClosedorCompleteDate",
        endKey:   "ClosedorCompleteEnd",
        label: "Closed / Complete",
        className: "seg-closed"
      },
      {
        startKey: "OnHold",
        endKey:   "OnHoldEnd",
        label: "On Hold",
        className: "seg-hold"
      },
      {
        startKey: "AtRiskorDelayed",
        endKey:   "AtRiskorDelayedEnd",
        label: "At Risk / Delayed",
        className: "seg-risk"
      }
    ];

    // Visible window: Oct 2025 through Sep 2026
    const MIN_START = new Date("2025-10-01T00:00:00");
    const MAX_END   = new Date("2026-09-30T23:59:59");

    // IMPORTANT BEHAVIOR:
    // If a phase has a start date but NO end date, do NOT draw it.
    // (This removes the old "ends at today" behavior.)
    const DRAW_OPEN_ENDED_PHASES = false;

    // If you ever set DRAW_OPEN_ENDED_PHASES = true, choose what the fallback end should be:
    // const OPEN_END_FALLBACK = MAX_END; // or new Date() if you want ongoing-to-today
    const OPEN_END_FALLBACK = MAX_END;

    // -----------------------------
    // HELPERS
    // -----------------------------
    const statusEl = document.getElementById("status");
    const layerUrl = `${FEATURESERVER_URL}/${LAYER_INDEX}`;

    const contactSelect = document.getElementById("contactSelect");
    const clearBtn = document.getElementById("clearBtn");

    function norm(v) { return (v ?? "").toString().trim().toLowerCase(); }

    function parseDate(val) {
      if (val === null || val === undefined || val === "") return null;

      // ArcGIS date fields: epoch ms
      if (typeof val === "number" || (typeof val === "string" && /^\d+$/.test(val))) {
        const d = new Date(Number(val));
        return isNaN(d) ? null : d;
      }

      // ISO-ish string fallback
      const d = new Date(val);
      return isNaN(d) ? null : d;
    }

    function isoDate(d) {
      const pad = n => String(n).padStart(2,"0");
      return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
    }
let lastRender = { filteredRows: [], items: [] };

    async function fetchAllRows() {
      const outFields = [
        PROJECT_ID_FIELD,
        PROJECT_NAME_FIELD,
        CONTACT_FIELD,
        ...PHASES.flatMap(p => [p.startKey, p.endKey])
      ].join(",");

      const pageSize = 2000;
      let offset = 0;
      let all = [];

      while (true) {
        const params = new URLSearchParams({
          where: "1=1",
          outFields,
          returnGeometry: "false",
          f: "json",
          resultOffset: String(offset),
          resultRecordCount: String(pageSize)
        });

        const resp = await fetch(`${layerUrl}/query?${params.toString()}`);
        const json = await resp.json();
        if (json.error) throw new Error(`${json.error.code}: ${json.error.message}`);

        const rows = (json.features || []).map(f => f.attributes);
        all = all.concat(rows);

        if (rows.length < pageSize) break;
        offset += pageSize;
      }

      return all;
    }

    // Build one group per project + segments from explicit start/end fields
    function buildGroupsAndItems(rows) {
      const ONE_DAY_MS = 24 * 60 * 60 * 1000;

      const groups = [];
      const items = [];

      // Sort by ProjectID
      rows.sort((a, b) => {
        const ai = a[PROJECT_ID_FIELD];
        const bi = b[PROJECT_ID_FIELD];
        if (ai == null) return 1;
        if (bi == null) return -1;
        return ai > bi ? 1 : ai < bi ? -1 : 0;
      });

      for (const r of rows) {
        const pid = r[PROJECT_ID_FIELD];
        const pname = (r[PROJECT_NAME_FIELD] ?? "(Unnamed Project)").toString();

        groups.push({
          id: String(pid),
          content: `<strong>${pid}</strong>&nbsp;&nbsp;${pname}`
        });

        for (const phase of PHASES) {
          const startRaw = parseDate(r[phase.startKey]);
          if (!startRaw) continue;

          let endRaw = parseDate(r[phase.endKey]);

          // If no end value: either skip or use fallback (but NOT "today" per your request)
          if (!endRaw) {
            if (!DRAW_OPEN_ENDED_PHASES) continue;
            endRaw = OPEN_END_FALLBACK;
          }

          // Clamp start/end to window
          const start = (startRaw < MIN_START) ? MIN_START : startRaw;
          let end = endRaw;
          if (end > MAX_END) end = MAX_END;

          // Minimum visible duration if equal/invalid
          if (end <= start) {
            const bumped = new Date(start.getTime() + ONE_DAY_MS);
            end = (bumped > MAX_END) ? MAX_END : bumped;
          }

          // Skip if outside
          if (start >= MAX_END) continue;
          if (end <= start) continue;

          items.push({
            id: `${pid}-${phase.startKey}`,
            group: String(pid),
            content: phase.label,
            start,
            end,
            type: "range",
            className: phase.className,

            // for export
            _projectId: pid,
            _projectName: pname,
            _contact: (r[CONTACT_FIELD] ?? "").toString(),
            _phase: phase.label
          });
        }
      }

      return { groups, items };
    }

    // -----------------------------
    // FILTERING (dropdown only)
    // -----------------------------
    function populateContactDropdown(allRows) {
      const set = new Set();
      for (const r of allRows) {
        const v = (r[CONTACT_FIELD] ?? "").toString().trim();
        if (v) set.add(v);
      }
      const contacts = Array.from(set).sort((a,b)=>a.localeCompare(b));

      contactSelect.innerHTML = "";

      const optAll = document.createElement("option");
      optAll.value = "";
      optAll.textContent = "All contacts";
      contactSelect.appendChild(optAll);

      const optBlank = document.createElement("option");
      optBlank.value = "__BLANK__";
      optBlank.textContent = "(No contact name)";
      contactSelect.appendChild(optBlank);

      for (const c of contacts) {
        const opt = document.createElement("option");
        opt.value = c;
        opt.textContent = c;
        contactSelect.appendChild(opt);
      }
    }

    function filterRows(allRows) {
      const sel = contactSelect.value;

      return allRows.filter(r => {
        const c = (r[CONTACT_FIELD] ?? "").toString().trim();
        if (sel === "__BLANK__") return !c;
        if (sel) return c === sel;
        return true;
      });
    }

    function applyFilter(allRows, groupsDS, itemsDS) {
      const filteredRows = filterRows(allRows);
      const { groups, items } = buildGroupsAndItems(filteredRows);

      groupsDS.clear(); groupsDS.add(groups);
      itemsDS.clear();  itemsDS.add(items);

      statusEl.textContent = `${groups.length} projects, ${items.length} segments`;
      return { filteredRows, items };
    }

    // -----------------------------
    // EXPORT CSV (segments)
    // -----------------------------
   
const exportCalendarXlsxBtn = document.getElementById("exportCalendarXlsxBtn");

// 12-month window matching your chart
const MONTHS = [
  { label: "Oct 2025", start: new Date("2025-10-01T00:00:00"), end: new Date("2025-11-01T00:00:00") },
  { label: "Nov 2025", start: new Date("2025-11-01T00:00:00"), end: new Date("2025-12-01T00:00:00") },
  { label: "Dec 2025", start: new Date("2025-12-01T00:00:00"), end: new Date("2026-01-01T00:00:00") },
  { label: "Jan 2026", start: new Date("2026-01-01T00:00:00"), end: new Date("2026-02-01T00:00:00") },
  { label: "Feb 2026", start: new Date("2026-02-01T00:00:00"), end: new Date("2026-03-01T00:00:00") },
  { label: "Mar 2026", start: new Date("2026-03-01T00:00:00"), end: new Date("2026-04-01T00:00:00") },
  { label: "Apr 2026", start: new Date("2026-04-01T00:00:00"), end: new Date("2026-05-01T00:00:00") },
  { label: "May 2026", start: new Date("2026-05-01T00:00:00"), end: new Date("2026-06-01T00:00:00") },
  { label: "Jun 2026", start: new Date("2026-06-01T00:00:00"), end: new Date("2026-07-01T00:00:00") },
  { label: "Jul 2026", start: new Date("2026-07-01T00:00:00"), end: new Date("2026-08-01T00:00:00") },
  { label: "Aug 2026", start: new Date("2026-08-01T00:00:00"), end: new Date("2026-09-01T00:00:00") },
  { label: "Sep 2026", start: new Date("2026-09-01T00:00:00"), end: new Date("2026-10-01T00:00:00") }
];

// Phase definitions for the calendar export (start, end, fill color, optional short label)
const CAL_PHASES = [
  { key: "design", label: "DES", start: "InDesignorProcurementDate", end: "InDesignorProcurementEnd", fill: "#1565c0" },
  { key: "active", label: "ACT", start: "ActiveImplementationConstructionDate", end: "ActiveImplementationConstructionEnd", fill: "#7ec8ff" },
  { key: "sub",   label: "SUB", start: "SubstantialCompletionorTestingDate", end: "SubstantialCompletionorTestingEnd", fill: "#f2c6a0" },
  { key: "closed",label: "CLS", start: "ClosedorCompleteDate", end: "ClosedorCompleteEnd", fill: "#2e7d32" },
  { key: "hold",  label: "HLD", start: "OnHold", end: "OnHoldEnd", fill: "#7b1fa2" },
  { key: "risk",  label: "RSK", start: "AtRiskorDelayed", end: "AtRiskorDelayedEnd", fill: "#c62828" }
];

// Overlap test: month [ms,me) overlaps interval [s,e]
function overlaps(monthStart, monthEnd, s, e) {
  return s < monthEnd && e > monthStart;
}

function makeCellCenter(value, fillHex, bold=false) {
  const cell = makeCell(value, fillHex, bold);
  cell.s.alignment = { vertical: "center", horizontal: "center", wrapText: true };
  return cell;
}

function exportCalendarXLSX(filteredRows) {
  if (!window.XLSX) {
    alert("XLSX library not loaded. Check the xlsx-js-style script tag.");
    return;
  }

  // Sort by ProjectID
  const rows = [...filteredRows].sort((a,b) => {
    const ai = a[PROJECT_ID_FIELD], bi = b[PROJECT_ID_FIELD];
    if (ai == null) return 1;
    if (bi == null) return -1;
    return ai > bi ? 1 : ai < bi ? -1 : 0;
  });

  const header = ["ProjectID", "Public_Project_Name", "Contact_Name", ...MONTHS.map(m => m.label)];

  const ws = {};
  const range = { s: { r:0, c:0 }, e: { r: rows.length, c: header.length-1 } };

  // Header row
  for (let c = 0; c < header.length; c++) {
    ws[XLSX.utils.encode_cell({ r:0, c })] = makeCell(header[c], "#F2F2F2", true);
  }

  // Data rows
  for (let i = 0; i < rows.length; i++) {
    const r = rows[i];
    const excelRow = i + 1;

    ws[XLSX.utils.encode_cell({ r: excelRow, c: 0 })] = makeCell(String(r[PROJECT_ID_FIELD] ?? ""), null);
    ws[XLSX.utils.encode_cell({ r: excelRow, c: 1 })] = makeCell(String(r[PROJECT_NAME_FIELD] ?? ""), null);
    ws[XLSX.utils.encode_cell({ r: excelRow, c: 2 })] = makeCell(String(r[CONTACT_FIELD] ?? ""), null);

    // Pre-parse phase intervals for this project (skip phases missing start OR end)
    const intervals = [];
    for (const p of CAL_PHASES) {
      const s = parseDate(r[p.start]);
      const e = parseDate(r[p.end]);
      if (s && e) intervals.push({ ...p, s, e });
    }

    // Fill month cells
    for (let m = 0; m < MONTHS.length; m++) {
      const month = MONTHS[m];

      // Find all phases that overlap this month
      const hits = intervals.filter(iv => overlaps(month.start, month.end, iv.s, iv.e));

      if (hits.length === 0) {
        ws[XLSX.utils.encode_cell({ r: excelRow, c: 3 + m })] = makeCellCenter("", null);
        continue;
      }

      // If multiple overlaps, choose the one with the latest start date
      hits.sort((a,b) => b.s - a.s);
      const chosen = hits[0];

      // If you want NO text inside colored cells, set value "" instead of chosen.label
      ws[XLSX.utils.encode_cell({ r: excelRow, c: 3 + m })] = makeCellCenter(chosen.label, chosen.fill);
    }
  }

  ws["!ref"] = XLSX.utils.encode_range(range);

  // Column widths: ID, Name, Contact, then months
  ws["!cols"] = [
    { wch: 12 },  // ProjectID
    { wch: 42 },  // Name
    { wch: 24 },  // Contact
    ...MONTHS.map(() => ({ wch: 10 }))
  ];

  ws["!freeze"] = { xSplit: 3, ySplit: 1 }; // freeze ID/Name/Contact + header

  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, "Calendar View");

  const wbout = XLSX.write(wb, { bookType: "xlsx", type: "array" });
  const blob = new Blob([wbout], {
    type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
  });

  const url = URL.createObjectURL(blob);
  const win = window.open(url, "_blank");

  if (!win) {
    const a = document.createElement("a");
    a.href = url;
    a.download = "CIP_Gantt_Calendar_Filtered.xlsx";
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

  setTimeout(() => URL.revokeObjectURL(url), 60_000);
}

// Wire up the new button
if (exportCalendarXlsxBtn) {
  exportCalendarXlsxBtn.addEventListener("click", () => {
    exportCalendarXLSX(lastRender.filteredRows);
  });
}


    // -----------------------------
    // RUN
    // -----------------------------
    (async () => {
      let allRows = [];
      try {
        statusEl.textContent = "Loading…";
        allRows = await fetchAllRows();

        populateContactDropdown(allRows);

        const groupsDS = new vis.DataSet([]);
        const itemsDS = new vis.DataSet([]);

        const container = document.getElementById("timeline");
        const options = {
          stack: false,
          horizontalScroll: true,
          zoomKey: "ctrlKey",
          min: MIN_START,
          max: MAX_END,
          start: MIN_START,
          end: MAX_END,
          orientation: "top",
          margin: { item: 6, axis: 8 }
        };

        const timeline = new vis.Timeline(container, itemsDS, groupsDS, options);

        // Today vertical line (clamped into window)
        const now = new Date();
        const todayClamped = (now < MIN_START) ? MIN_START : (now > MAX_END) ? MAX_END : now;
        timeline.addCustomTime(todayClamped, "today");
        const todayBar = timeline.customTimes["today"];
        if (todayBar && todayBar.bar) todayBar.bar.classList.add("today-line");

        // Initial render
        lastRender = applyFilter(allRows, groupsDS, itemsDS);

        // Events
        function rerender() {
          lastRender = applyFilter(allRows, groupsDS, itemsDS);
        }

        contactSelect.addEventListener("change", rerender);

        clearBtn.addEventListener("click", () => {
          contactSelect.value = "";
          rerender();
        });


      } catch (e) {
        console.error(e);
        statusEl.textContent = `Error: ${e.message}`;
        document.getElementById("timeline").innerHTML =
          `<div style="padding:12px;font-family:system-ui;color:#b00;">
             CIP Timeline Error: ${e.message}<br>
             Failed to load. Check layer index and field names (including new End fields).
           </div>`;
      }
    })();
    
  </script>
</body>
</html>
